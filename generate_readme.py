# generate_readme.py
# Save this file into your module folder and run `python3 generate_readme.py`

import re
from pathlib import Path
import textwrap
import tempfile

VARIABLE_BLOCK_RE = re.compile(r'variable\s+"([^"]+)"\s*\{([^}]*)\}', re.DOTALL)
OUTPUT_BLOCK_RE = re.compile(r'output\s+"([^"]+)"\s*\{([^}]*)\}', re.DOTALL)


def extract_kv(block_text, key):
    m = re.search(
        r'{0}\s*=\s*(?P<val>("([^"\\]|\\.)*"|[^\n]+))'.format(re.escape(key)),
        block_text,
    )
    if not m:
        return None
    val = m.group("val").strip()
    if val.startswith('"') and val.endswith('"'):
        return val[1:-1]
    return val


def parse_variables(content):
    vars = []
    for name, block in VARIABLE_BLOCK_RE.findall(content):
        desc = extract_kv(block, "description") or ""
        typ = extract_kv(block, "type") or ""
        default = extract_kv(block, "default") or ""
        vars.append(
            {
                "name": name,
                "type": typ.strip(),
                "default": default.strip(),
                "description": desc.strip(),
            }
        )
    return vars


def parse_outputs(content):
    outs = []
    for name, block in OUTPUT_BLOCK_RE.findall(content):
        desc = extract_kv(block, "description") or ""
        outs.append({"name": name, "description": desc.strip()})
    return outs


def make_table(headers, rows):
    col_widths = [len(h) for h in headers]
    for r in rows:
        for i, cell in enumerate(r):
            col_widths[i] = max(col_widths[i], len(cell))
    header_row = (
        "| " + " | ".join(h.ljust(col_widths[i]) for i, h in enumerate(headers)) + " |"
    )
    divider = "|-" + "-|-".join("-" * col_widths[i] for i in range(len(headers))) + "-|"
    body_lines = []
    for r in rows:
        body_lines.append(
            "| "
            + " | ".join(r[i].ljust(col_widths[i]) for i in range(len(headers)))
            + " |"
        )
    return "\n".join([header_row, divider] + body_lines) + "\n"


def generate_readme(module_path: Path, out_path: Path):
    vars_path = module_path / "variables.tf"
    outputs_path = module_path / "outputs.tf"
    vars_content = vars_path.read_text() if vars_path.exists() else ""
    outputs_content = outputs_path.read_text() if outputs_path.exists() else ""

    variables = parse_variables(vars_content)
    outputs = parse_outputs(outputs_content)

    if variables:
        rows = []
        for v in variables:
            rows.append(
                [
                    v["name"],
                    v["type"] or "string",
                    v["default"] or "-",
                    v["description"] or "-",
                ]
            )
        inputs_table = make_table(["Name", "Type", "Default", "Description"], rows)
    else:
        inputs_table = "_No variables.tf found or no variables detected._\n"

    if outputs:
        rows = []
        for o in outputs:
            rows.append([o["name"], o["description"] or "-"])
        outputs_table = make_table(["Name", "Description"], rows)
    else:
        outputs_table = "_No outputs.tf found or no outputs detected._\n"

    readme_md = textwrap.dedent(
        f"""\
    # Module README (auto-generated)

    _This README was generated by `generate_readme.py`. Review and edit for clarity before publishing._

    ## Quick description
    Reusable Terraform module. Customize this short paragraph to explain the purpose of the module.

    ## Usage
    ```hcl
    module "example" {{
      source = "./"  # or "github.com/owner/repo//path?ref=vX.Y.Z"
      # ... module variables ...
    }}
    ```

    ## Examples
    See the `examples/` folder for full usage examples.

    ## Inputs
    {inputs_table}

    ## Outputs
    {outputs_table}

    ## Providers
    - `aws` (example) — ensure provider is configured in root module.

    ## Requirements
    - Terraform 1.x
    - Provider constraints in `versions.tf`

    ## Notes
    - This file is a starting point — update descriptions and add missing variables/outputs.
    - When publishing to the Terraform Registry, ensure this README.md lives at the module path.

    ## License
    See the repo `LICENSE` file.
    """
    )
    out_path.write_text(readme_md)
    return readme_md


if __name__ == "__main__":
    # by default operate on the current directory
    module_dir = Path(".")
    out_file = module_dir / "README.generated.md"
    print(
        "Generating README.generated.md from variables.tf and outputs.tf in",
        module_dir.resolve(),
    )
    generated = generate_readme(module_dir, out_file)
    print("Wrote:", out_file)
    print()
    print(generated)
